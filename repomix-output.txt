This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-12T16:44:56.794Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  CMakeLists.txt
  main.cpp
  matmul.cpp
  matmul.h
tests/
  CMakeLists.txt
  test_matmul.cpp
.gitignore
CMakeLists.txt
README.md
run_tests.sh

================================================================
Files
================================================================

================
File: src/CMakeLists.txt
================
add_library(matmul matmul.cpp)

add_executable(main main.cpp)
target_link_libraries(main matmul)

================
File: src/main.cpp
================
#include "matmul.h"
#include <iostream>
#include <chrono>

using namespace std;

double benchmark(const Matrix &A, const Matrix &B, size_t iterations, bool use_blocked, size_t block_size = 32) {
    double total = 0.0;
    for (size_t i = 0; i < iterations; ++i) {
        auto start = chrono::high_resolution_clock::now();
        Matrix C = use_blocked ? blocked_multiply(A, B, block_size) : naive_multiply(A, B);
        auto end = chrono::high_resolution_clock::now();
        total += chrono::duration<double>(end - start).count();
    }
    return total / iterations;
}

int main() {
    cout << "size,naive,blocked\n";
    std::vector<size_t> sizes = {64, 128, 256, 512};
    size_t iterations = 3;
    size_t block_size = 32;

    for (auto s : sizes) {
        Matrix A = random_matrix(s);
        Matrix B = random_matrix(s);
        double t_naive = benchmark(A, B, iterations, false);
        double t_blocked = benchmark(A, B, iterations, true, block_size);
        cout << s << "," << t_naive << "," << t_blocked << "\n";
    }
    return 0;
}

================
File: src/matmul.cpp
================
#include "matmul.h"
#include <random>
#include <cmath>

Matrix naive_multiply(const Matrix &A, const Matrix &B) {
    size_t n = A.size();
    Matrix C(n, std::vector<double>(n, 0.0));
    for (size_t i = 0; i < n; ++i)
        for (size_t j = 0; j < n; ++j)
            for (size_t k = 0; k < n; ++k)
                C[i][j] += A[i][k] * B[k][j];
    return C;
}

Matrix blocked_multiply(const Matrix &A, const Matrix &B, size_t block_size) {
    size_t n = A.size();
    Matrix C(n, std::vector<double>(n, 0.0));
    for (size_t i0 = 0; i0 < n; i0 += block_size)
        for (size_t j0 = 0; j0 < n; j0 += block_size)
            for (size_t k0 = 0; k0 < n; k0 += block_size)
                for (size_t i = i0; i < std::min(i0 + block_size, n); ++i)
                    for (size_t k = k0; k < std::min(k0 + block_size, n); ++k)
                        for (size_t j = j0; j < std::min(j0 + block_size, n); ++j)
                            C[i][j] += A[i][k] * B[k][j];
    return C;
}

Matrix random_matrix(size_t n) {
    Matrix M(n, std::vector<double>(n));
    std::mt19937 rng(42);
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    for (size_t i = 0; i < n; ++i)
        for (size_t j = 0; j < n; ++j)
            M[i][j] = dist(rng);
    return M;
}

bool are_matrices_equal(const Matrix &A, const Matrix &B, double tol) {
    if (A.size() != B.size() || A[0].size() != B[0].size())
        return false;
    for (size_t i = 0; i < A.size(); ++i)
        for (size_t j = 0; j < A[0].size(); ++j)
            if (std::fabs(A[i][j] - B[i][j]) > tol)
                return false;
    return true;
}

================
File: src/matmul.h
================
#ifndef MATMUL_H
#define MATMUL_H

#include <vector>
#include <cstddef>

using Matrix = std::vector<std::vector<double>>;

Matrix naive_multiply(const Matrix &A, const Matrix &B);
Matrix blocked_multiply(const Matrix &A, const Matrix &B, size_t block_size);
Matrix random_matrix(size_t n);
bool are_matrices_equal(const Matrix &A, const Matrix &B, double tol = 1e-9);

#endif

================
File: tests/CMakeLists.txt
================
enable_testing()

add_executable(test_matmul test_matmul.cpp)
target_link_libraries(test_matmul PRIVATE matmul)
target_include_directories(test_matmul PRIVATE ${CMAKE_SOURCE_DIR}/src)

add_test(NAME test_matmul COMMAND ${CMAKE_BINARY_DIR}/tests/test_matmul)
set_tests_properties(test_matmul PROPERTIES WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})

================
File: tests/test_matmul.cpp
================
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "matmul.h"

TEST_CASE("2x2 matrix multiplication", "[matmul]") {
    Matrix A = { {1, 2}, {3, 4} };
    Matrix B = { {5, 6}, {7, 8} };
    Matrix expected = { {19, 22}, {43, 50} };

    Matrix res_naive = naive_multiply(A, B);
    Matrix res_blocked = blocked_multiply(A, B, 1); 

    REQUIRE(are_matrices_equal(res_naive, expected));
    REQUIRE(are_matrices_equal(res_blocked, expected));
}

================
File: .gitignore
================
CMakeLists.txt.user
CMakeCache.txt
CMakeFiles
CMakeScripts
Testing
Makefile
cmake_install.cmake
install_manifest.txt
compile_commands.json
CTestTestfile.cmake
_deps
CMakeUserPresets.json

# Ignore build artifacts
/build/
*.o
*.obj
*.a
*.lib
*.so
*.dll
*.dylib
*.exe

# Ignore CMake files
/CMakeCache.txt
/CMakeFiles/
/cmake_install.cmake
/Makefile

# Ignore test binaries and logs
/tests/test_matmul
/tests/CTestTestfile.cmake

# Ignore IDE files
.vscode/
.idea/
*.code-workspace

# Ignore dependency files (if using vcpkg or external libs)
external/

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.10)
project(FastMatMul)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_subdirectory(src)
add_subdirectory(tests)

================
File: README.md
================
# FastMatMul

FastMatMul implements various matrix multiplication algorithms in C++. 

## Project Structure
- **src/**: Contains the main implementation.
- **tests/**: Contains unit tests using Catch2.

## Build & Run
### Build
```bash
mkdir build && cd build
cmake ..
cmake --build .

sudo nala install catch2

================
File: run_tests.sh
================
#!/bin/bash

set -e  

rm -rf build
mkdir build && cd build

cmake ..
cmake --build .

ctest --output-on-failure



================================================================
End of Codebase
================================================================
